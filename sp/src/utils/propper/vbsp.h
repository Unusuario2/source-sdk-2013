//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: 
//
// $NoKeywords: $
//
//=============================================================================//

#if !defined( VBSP_H )
#define VBSP_H

	   
#include "cmdlib.h"
#include "mathlib/vector.h"
#include "scriplib.h"
#include "polylib.h"
#include "threads.h"
#include "bsplib.h"
#include "qfiles.h"
#include "utilmatlib.h"
#include "ChunkFile.h"

#ifdef WIN32
#pragma warning( disable: 4706 )
#endif

class CUtlBuffer;

#define	MAX_BRUSH_SIDES	128
#define	CLIP_EPSILON	0.1

#define	TEXINFO_NODE		-1		// side is allready on a node

// this will output glview files for the given brushmodel.  Brushmodel 1 is the world, 2 is the first brush entity, etc.
#define DEBUG_BRUSHMODEL 0

struct portal_t;
struct node_t;

struct plane_t : public dplane_t
{
	plane_t			*hash_chain;

	plane_t() { normal.Init(); }
};


struct brush_texture_t
{
	Vector	UAxis;
	Vector	VAxis;
	vec_t	shift[2];
	vec_t	rotate;
	vec_t	textureWorldUnitsPerTexel[2];
	vec_t	lightmapWorldUnitsPerLuxel;
	char	name[TEXTURE_NAME_LENGTH];
	int		flags;

	brush_texture_t() : UAxis(0,0,0), VAxis(0,0,0) {}
};

struct mapdispinfo_t;

struct side_t
{
	int			    planenum;
	int			    texinfo;
	mapdispinfo_t	*pMapDisp;

	winding_t	    *winding;
	side_t			*original;	    // bspbrush_t sides will reference the mapbrush_t sides
	int			    contents;		// from miptex
	int			    surf;			// from miptex
	qboolean	    visible;		// choose visble planes first
	qboolean	    tested;			// this plane allready checked as a split
	qboolean	    bevel;			// don't ever use for bsp splitting

	int td_num; //Carl--for finding brushtextures
	brush_texture_t	td;
	side_t			*next;
    int             origIndex;      
	int				id;				// This is the unique id generated by worldcraft for this side.
	unsigned int	smoothingGroups;
	CUtlVector<int>	aOverlayIds;		// List of overlays that reside on this side.
	CUtlVector<int>	aWaterOverlayIds;	// List of water overlays that reside on this side.
	bool			m_bDynamicShadowsEnabled;	// Goes into dface_t::SetDynamicShadowsEnabled().
};

struct mapbrush_t
{
	int		entitynum;
	int		brushnum;
	int		id;						// The unique ID of this brush in the editor, used for reporting errors.
	int		contents;
	Vector	mins, maxs;
	int		numsides;
	side_t	*original_sides;
};

#define	PLANENUM_LEAF			-1

#define	MAXEDGES		32

struct face_t
{
	int				id;

	face_t			*next;		            // on node

	// the chain of faces off of a node can be merged or split,
	// but each face_t along the way will remain in the chain
	// until the entire tree is freed
	face_t			*merged;	            // if set, this face isn't valid anymore
	face_t			*split[2];	            // if set, this face isn't valid anymore

	portal_t		*portal;
	int				texinfo;
	int             dispinfo;
	// This is only for surfaces that are the boundaries of fog volumes
	// (ie. water surfaces)
	// All of the rest of the surfaces can look at their leaf to find out
	// what fog volume they are in.
	node_t			*fogVolumeLeaf;

    int				planenum;
	int				contents;	            // faces in different contents can't merge
	int				outputnumber;
	winding_t		*w;
	int				numpoints;
	qboolean		badstartvert;	        // tjunctions cannot be fixed without a midpoint vertex
	int				vertexnums[MAXEDGES];
    side_t          *originalface;          // save the "side" this face came from
	int				firstPrimID;
	int				numPrims;
	unsigned int	smoothingGroups;
};

void EmitFace( face_t *f, qboolean onNode );

struct mapdispinfo_t
{
	face_t			face;
	int				entitynum;
    int				power;
    int				minTess;
    float			smoothingAngle;
    Vector			uAxis;
    Vector			vAxis;
	Vector			startPosition;
	float			alphaValues[MAX_DISPVERTS];
    float			maxDispDist;
    float			dispDists[MAX_DISPVERTS];
    Vector			vectorDisps[MAX_DISPVERTS];
	Vector			vectorOffsets[MAX_DISPVERTS];
    int				contents;
	int				brushSideID;
	brush_texture_t	td;
	int td_num; //Carl--for finding brushtextures
	unsigned short	triTags[MAX_DISPTRIS];
	int				flags;

#ifdef VSVMFIO
	float			m_elevation;						// "elevation"
	Vector			m_offsetNormals[ MAX_DISPTRIS ];	// "offset_normals"
#endif // VSVMFIO

};

extern mapdispinfo_t    mapdispinfo[MAX_MAP_DISPINFO];

extern int				g_nDXLevel;

struct bspbrush_t
{
	int					id;
	bspbrush_t			*next;
	Vector	            mins, maxs;
	int		            side, testside;		// side of node during construction
	mapbrush_t	        *original;
	int		            numsides;
	side_t	            sides[6];			// variably sized
};


#define	MAX_NODE_BRUSHES	8

struct leafface_t 
{
	face_t		*pFace;
	leafface_t	*pNext;
};

struct node_t
{
	int				id;

	// both leafs and nodes
	int				planenum;	// -1 = leaf node
	node_t			*parent;
	Vector			mins, maxs;	// valid after portalization
	bspbrush_t		*volume;	// one for each leaf/node

	// nodes only
	side_t			*side;		// the side that created the node
	node_t			*children[2];
	face_t			*faces;		// these are the cutup ones that live in the plane of "side".

	// leafs only
	bspbrush_t		*brushlist;	// fragments of all brushes in this leaf
	leafface_t		*leaffacelist;
	int				contents;	// OR of all brush contents
	int				occupied;	// 1 or greater can reach entity
	entity_t		*occupant;	// for leak file testing
	int				cluster;	// for portalfile writing
	int				area;		// for areaportals
	portal_t		*portals;	// also on nodes during construction
	int				diskId;		// dnodes or dleafs index after this has been emitted
};


struct portal_t
{
	int				id;
	plane_t		    plane;
	node_t		    *onnode;		// NULL = outside box
	node_t		    *nodes[2];		// [0] = front side of plane
	portal_t		*next[2];
	winding_t	    *winding;
	qboolean	    sidefound;		// false if ->side hasn't been checked
	side_t		    *side;			// NULL = non-visible
	face_t		    *face[2];		// output face in bsp file
};


struct tree_t
{
	node_t		*headnode;
	node_t		outside_node;
	Vector		mins, maxs;
	bool		leaked;
};


extern	int			entity_num;

struct LoadSide_t;
struct LoadEntity_t;
class CManifest;

class CMapFile
{
public:
			CMapFile( void ) { Init(); }

	void	Init( void );

	void				AddPlaneToHash (plane_t *p);
	int					CreateNewFloatPlane (Vector& normal, vec_t dist);
	int					FindFloatPlane (Vector& normal, vec_t dist);
	int					PlaneFromPoints(const Vector &p0, const Vector &p1, const Vector &p2);
	void				AddBrushBevels (mapbrush_t *b);
	qboolean			MakeBrushWindings (mapbrush_t *ob);
	void				MoveBrushesToWorld( entity_t *mapent );
	void				MoveBrushesToWorldGeneral( entity_t *mapent );
	void				RemoveContentsDetailFromEntity( entity_t *mapent );
	int					SideIDToIndex( int brushSideID );
	void				AddLadderKeys( entity_t *mapent );
	ChunkFileResult_t	LoadEntityCallback(CChunkFile *pFile, int nParam);
	void				ForceFuncAreaPortalWindowContents();
	ChunkFileResult_t	LoadSideCallback(CChunkFile *pFile, LoadSide_t *pSideInfo);
	ChunkFileResult_t	LoadConnectionsKeyCallback(const char *szKey, const char *szValue, LoadEntity_t *pLoadEntity);
	ChunkFileResult_t	LoadSolidCallback(CChunkFile *pFile, LoadEntity_t *pLoadEntity);
	void				TestExpandBrushes(void);

	static char			m_InstancePath[ MAX_PATH ];
	static void			SetInstancePath( const char *pszInstancePath );
	static const char	*GetInstancePath( void ) { return m_InstancePath; }
	static bool			DeterminePath( const char *pszBaseFileName, const char *pszInstanceFileName, char *pszOutFileName );

	void				CheckForInstances( const char *pszFileName );
	void				MergeInstance( entity_t *pInstanceEntity, CMapFile *Instance );
	//void				MergePlanes( entity_t *pInstanceEntity, CMapFile *Instance, Vector &InstanceOrigin, QAngle &InstanceAngle, matrix3x4_t &InstanceMatrix );
	//void				MergeBrushes( entity_t *pInstanceEntity, CMapFile *Instance, Vector &InstanceOrigin, QAngle &InstanceAngle, matrix3x4_t &InstanceMatrix );
	//void				MergeBrushSides( entity_t *pInstanceEntity, CMapFile *Instance, Vector &InstanceOrigin, QAngle &InstanceAngle, matrix3x4_t &InstanceMatrix );
	void				ReplaceInstancePair( epair_t *pPair, entity_t *pInstanceEntity );
	//void				MergeEntities( entity_t *pInstanceEntity, CMapFile *Instance, Vector &InstanceOrigin, QAngle &InstanceAngle, matrix3x4_t &InstanceMatrix );
	//void				MergeOverlays( entity_t *pInstanceEntity, CMapFile *Instance, Vector &InstanceOrigin, QAngle &InstanceAngle, matrix3x4_t &InstanceMatrix );

	static int	m_InstanceCount;
	static int	c_areaportals;

	plane_t		mapplanes[MAX_MAP_PLANES];
	int			nummapplanes;

	#define	PLANE_HASHES	1024
	plane_t		*planehash[PLANE_HASHES];

	int			nummapbrushes;
	mapbrush_t	mapbrushes[MAX_MAP_BRUSHES];

	Vector		map_mins, map_maxs;

	int			nummapbrushsides;
	side_t		brushsides[MAX_MAP_BRUSHSIDES];

	brush_texture_t side_brushtextures[MAX_MAP_BRUSHSIDES];

	int			num_entities;
	entity_t	entities[MAX_MAP_ENTITIES];

	int			c_boxbevels;
	int			c_edgebevels;
	int			c_clipbrushes;
	int			g_ClipTexinfo;

	class CConnectionPairs
	{
		public:
		CConnectionPairs( epair_t *pair, CConnectionPairs *next )
		{
			m_Pair = pair;
			m_Next = next;
		}

		epair_t				*m_Pair;
		CConnectionPairs	*m_Next;
	};

	CConnectionPairs	*m_ConnectionPairs;

	int					m_StartMapOverlays;
	int					m_StartMapWaterOverlays;
};

extern CMapFile	*g_MainMap;
extern CMapFile	*g_LoadingMap;

extern CUtlVector< CMapFile * > g_Maps;

extern	int			g_nMapFileVersion;

extern	char		outbase[32];

extern	char	source[1024];
extern char		mapbase[ 64 ];
extern CUtlVector<int> g_SkyAreas;
//Carl
extern bool logging;
extern bool dobodygroup;
extern char* sourcefolder;
#define SMOOTH_NO 0
#define SMOOTH_DEFAULT 1
#define SMOOTH_GROUPSONLY 2
#define CENTER_NO 0
#define CENTER_AUTO 1
#define CENTER_ORIGIN 2

extern bool objExport;
extern bool studioCompile;
extern bool fixMaterials;
extern bool mat_nonormal;
extern int smdmaterials;

extern char targetPath[1024];

struct smd_point_t{
	Vector p, n;
	double u, v;
	int smooth;//what group of verts will this smooth with
	int weld;
	int brush;
	unsigned int wcSmooth;//smoothing in Hammer. This is a bitmask. 32 bits.
};
#define MAX_SMD_VERTS 32766

//leave [0] blank. Why? Ive slept since I wrote this...
//Oh, it's so we can have a smooth value of zero I think.

//TODO: get rid of this and put it in scope of makeSMD 
//Actually don't do that because it causes stack overflow
extern smd_point_t smd_pts[MAX_SMD_VERTS+1];

struct smd_triangle_t
{
	int		brush;
	int p[3];
	char	material[128];
};
#define MAX_SMD_TRIS 10922
extern smd_triangle_t smd_tris[MAX_SMD_TRIS];

struct phys_data_t{
	char* model;
	const char* base;
	int health;
	int physicsmode;
	bool flammable;
	bool ignite;
	bool explosive_resist;
	float explosive_damage;
	float explosive_radius;
	const char* breakable_model;
	int breakable_count;
	int breakable_skin;
};
struct phys_interactions_t{
	Vector angles;
	bool preferred_carryangles;
	bool stick;
	bool bloodsplat;
	bool break_;
	bool paintsplat;
	bool impale;
	const char* onlaunch;
	bool explode_fire;
};

struct skins_t{
	const char* mat[15];
	int suffix[15];
};

struct gibs_t{
	const char* gibmodel;
	const char* ragdoll;
	int debris;
	int burst;
	int fadetime;
	int fademindist;
	int fademaxdist;
};

struct lods_t{
//	const char* entname;
	int entnum;
	float weldvertices;
	int distance;
	bool written;
};

struct particles_t{
	const char* name;
	const char* attachment_type;
	const char* attachment_point;
};

struct cables_t{
	const char* start;
	const char* end;
	const char* mat;
	int width;
	int segments;
	int length;
};

struct attachments_t{
	const char* name;
	Vector angles;
	Vector origin;
};

struct bodygroups_t{
	char* groupname;
	int body_ents[16];
};
extern bodygroups_t bodygroups;

struct model_t{ //lol model T
	char* ent_name;
	char* qc_cdmaterials;
	char* qc_surfaceprop;
	float qc_scale;
	char* qc_modelname;
	char basename[128];
	int phys_entnum;
	int ref_entnum;
	int smoothing;
	int smoothangle;
	bool qc_concave;
	bool qc_autocenter;
	bool snaptogrid;
	float ref_weldvertices;
	char* phys_entname;
	bool dophysmodel;
	bool disp_nowarp;
	bool physicsprop;
	bool phys_interactions;
	float mass;
	Vector origin;
	phys_data_t* phy;
	phys_interactions_t* phys_int;
	skins_t skins[16];//allocate with new
	int num_skinfamilies;
	int num_gibs;
	gibs_t gibs[16];//allocate with new [16];
	int num_lods;
	lods_t lods[16];
	int num_particles;
	particles_t particles[16];
	int num_cables;
	cables_t cables[16];
	int num_attachments;
	attachments_t att[16];
	int num_physhulls;
public:
	void MakeQC();
	void getMapProperties();
};
#define MAX_PROPPER_MODELS 1024
extern model_t propper_models[MAX_PROPPER_MODELS];

extern int num_models;

struct smd_texture_t{
	char* texpath;
	char* texname;
	smd_texture_t* next;
};
extern smd_texture_t* smd_textures;

extern char FixdTextures[1048576];
//Carl end

bool 	LoadMapFile( const char *pszFileName );
int		GetVertexnum( Vector& v );

struct textureref_t
{
	char	name[TEXTURE_NAME_LENGTH];
	int		flags;
	float	lightmapWorldUnitsPerLuxel;
	int		contents;
};

extern	textureref_t	textureref[MAX_MAP_TEXTURES];

//=============================================================================
// procedurally created .vmt files
//=============================================================================

void EmitStaticProps();

// draw.c

extern Vector	draw_mins, draw_maxs;
extern bool g_bLightIfMissing;

void Draw_ClearWindow (void);

enum detailscreen_e
{
	FULL_DETAIL = 0,
	ONLY_DETAIL = 1,
	NO_DETAIL	= 2,
};

#endif

